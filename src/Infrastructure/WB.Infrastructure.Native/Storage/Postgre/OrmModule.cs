using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Serialization;
using Humanizer;
using NHibernate;
using NHibernate.Cfg;
using NHibernate.Cfg.MappingSchema;
using NHibernate.Mapping.ByCode;
using NHibernate.Mapping.ByCode.Conformist;
using Ninject;
using WB.Core.GenericSubdomains.Portable;
using WB.Core.GenericSubdomains.Portable.ServiceLocation;
using WB.Core.Infrastructure.Modularity;
using WB.Core.Infrastructure.PlainStorage;
using WB.Core.Infrastructure.ReadSide.Repository.Accessors;
using WB.Infrastructure.Native.Monitoring;
using WB.Infrastructure.Native.Storage.Postgre.Implementation;
using WB.Infrastructure.Native.Storage.Postgre.NhExtensions;

namespace WB.Infrastructure.Native.Storage.Postgre
{
    public class OrmModule : IModule
    {
        private readonly UnitOfWorkConnectionSettings connectionSettings;

        public OrmModule(UnitOfWorkConnectionSettings connectionSettings) 
        {
            this.connectionSettings = connectionSettings;
        }

        public Task Init(IServiceLocator serviceLocator, UnderConstructionInfo status)
        {
            return Task.CompletedTask;
        }

        public void Load(IIocRegistry registry)
        {
            registry.BindToConstant(() => this.connectionSettings);
            registry.BindToMethodInSingletonScope<ISessionFactory>(context => this.BuildSessionFactory(), "mainFactory");
            registry.BindInIsolatedThreadScopeOrRequestScopeOrThreadScope<IUnitOfWork, UnitOfWork>();

            registry.Bind(typeof(IQueryableReadSideRepositoryReader<>), typeof(PostgreReadSideStorage<>));
            registry.Bind(typeof(IQueryableReadSideRepositoryReader<,>), typeof(PostgreReadSideStorage<,>));

            registry.Bind(typeof(IReadSideRepositoryReader<>), typeof(PostgreReadSideStorage<>));
            registry.Bind(typeof(IReadSideRepositoryReader<,>), typeof(PostgreReadSideStorage<,>)); 

            registry.Bind(typeof(INativeReadSideStorage<>), typeof(PostgreReadSideStorage<>));
            registry.Bind(typeof(INativeReadSideStorage<,>), typeof(PostgreReadSideStorage<,>));

            registry.Bind(typeof(PostgreReadSideStorage<>), typeof(PostgreReadSideStorage<>));
            registry.Bind(typeof(PostgreReadSideStorage<,>), typeof(PostgreReadSideStorage<,>));

            registry.Bind(typeof(IReadSideRepositoryWriter<>), typeof(PostgreReadSideStorage<>));
            registry.Bind(typeof(IReadSideRepositoryWriter<,>), typeof(PostgreReadSideStorage<,>));

            registry.Bind(typeof(IPlainStorageAccessor<>), typeof(PostgresPlainStorageRepository<>));
            registry.Bind(typeof(IPlainKeyValueStorage<>), typeof(PostgresPlainKeyValueStorage<>));
            registry.BindAsSingleton(typeof(IEntitySerializer<>), typeof(EntitySerializer<>));
        }

        private ISessionFactory BuildSessionFactory()
        {
            var cfg = new Configuration();
            cfg.DataBaseIntegration(db =>
            {
                db.ConnectionString = this.connectionSettings.ConnectionString;
                db.Dialect<PostgreSQL91Dialect>();
                db.KeywordsAutoImport = Hbm2DDLKeyWords.Keywords;
            });

            var maps = this.GetReadSideMappings();
            var plainMaps = this.GetPlainMappings();

            cfg.AddDeserializedMapping(maps, "");
            cfg.AddDeserializedMapping(plainMaps, "");
            cfg.SetProperty(NHibernate.Cfg.Environment.WrapResultSets, "true");

            File.WriteAllText(@"D:\Temp\Mapping.xml" , Serialize(maps)); // Can be used to check mappings

            cfg.SessionFactory().GenerateStatistics();

            var sessionFactory = cfg.BuildSessionFactory();

            MetricsRegistry.Instance.RegisterOnDemandCollectors(
                new NHibernateStatsCollector("", sessionFactory)
            );

            return sessionFactory;
        }


        /// <summary>
        /// Generates XML string from <see cref="NHibernate"/> mappings. Used just to verify what was generated by ConfOrm to make sure everything is correct.
        /// </summary>
        protected static string Serialize(HbmMapping hbmElement)
        {
            var setting = new XmlWriterSettings { Indent = true };
            var serializer = new XmlSerializer(typeof(HbmMapping));
            using (var memStream = new MemoryStream())
            {
                using (var xmlWriter = XmlWriter.Create(memStream, setting))
                {
                    serializer.Serialize(xmlWriter, hbmElement);
                    memStream.Flush();
                    byte[] streamContents = memStream.ToArray();

                    string result = Encoding.UTF8.GetString(streamContents);
                    return result;
                }
            }
        }

        private HbmMapping GetReadSideMappings()
        {
            var mapper = new ModelMapper();
            var readSideMappingTypes = this.connectionSettings.ReadSideMappingAssemblies.SelectMany(x => x.GetExportedTypes())
                .Where(x => x.GetCustomAttribute<PlainStorageAttribute>() == null && 
                            x.IsSubclassOfRawGeneric(typeof(ClassMapping<>)));

            mapper.AddMappings(readSideMappingTypes);
            var schemaName = this.connectionSettings.ReadSideSchemaName;

            CustomizeMappings(mapper, schemaName);

            return mapper.CompileMappingForAllExplicitlyAddedEntities();
        }
        
        private HbmMapping GetPlainMappings()
        {
            var mapper = new ModelMapper();
            var plainStoreMappingTypes = this.connectionSettings.PlainMappingAssemblies
                .SelectMany(x => x.GetExportedTypes())
                .Where(x => x.GetCustomAttribute<PlainStorageAttribute>() != null &&
                            x.IsSubclassOfRawGeneric(typeof(ClassMapping<>)));
            mapper.AddMappings(plainStoreMappingTypes);
            CustomizeMappings(mapper, this.connectionSettings.PlainStorageSchemaName);


            return mapper.CompileMappingForAllExplicitlyAddedEntities();
        }

        private static void CustomizeMappings(ModelMapper mapper, string schemaName)
        {
            mapper.BeforeMapProperty += (inspector, member, customizer) =>
            {
                var propertyInfo = (PropertyInfo) member.LocalMember;
                if (propertyInfo.PropertyType == typeof(string))
                {
                    customizer.Type(NHibernateUtil.StringClob);
                }
            };

            mapper.BeforeMapClass += (inspector, type, customizer) =>
            {
                var tableName = type.Name.Pluralize();
                customizer.Table(tableName);
                customizer.Schema(schemaName);
            };

            mapper.BeforeMapSet += (inspector, member, customizer) => customizer.Schema(schemaName);
            mapper.BeforeMapBag += (inspector, member, customizer) => customizer.Schema(schemaName);
            mapper.BeforeMapList += (inspector, member, customizer) => customizer.Schema(schemaName);
        }
    }

    public class UnitOfWorkConnectionSettings
    {
        public string ConnectionString { get; set; }

        public string PlainStorageSchemaName { get; set; }
        public string ReadSideSchemaName { get; set; }

        public IList<Assembly> PlainMappingAssemblies { get; set; }
        public IList<Assembly> ReadSideMappingAssemblies { get; set; }
    }

    public interface IUnitOfWork : IDisposable
    {
        void AcceptChanges();
        ISession Session { get; }
    }

    [DebuggerDisplay("Id = {Id}")]
    public sealed class UnitOfWork : IUnitOfWork
    {
        private readonly ISessionFactory sessionFactory;
        private ISession session;
        private ITransaction transaction;
        private bool isDisposed = false;
        private static int Counter = 0;
        public int Id { get; set; }

        public UnitOfWork([Named("mainFactory")]ISessionFactory sessionFactory)
        {
            this.sessionFactory = sessionFactory;
            Id = Interlocked.Increment(ref Counter);

            if(session != null) throw new InvalidOperationException("Unit of work already started");
            if(isDisposed == true) throw new ObjectDisposedException(nameof(UnitOfWork));

            session = this.sessionFactory.OpenSession();
            transaction = session.BeginTransaction();
        }

        public void AcceptChanges()
        {
            if(isDisposed) throw new ObjectDisposedException(nameof(UnitOfWork));

            transaction.Commit();
            session.Close();
            transaction = null;
            session = null;
        }

        public ISession Session
        {
            get
            {
                if(isDisposed) throw new ObjectDisposedException(nameof(UnitOfWork));
                return session;
            }
        } 

        public void Dispose()
        {
            if (isDisposed) return;

            if (transaction != null)
            {
                transaction.Rollback();
                transaction = null;
            }

            if (session != null)
            {
                session.Close();
                session = null;
            }

            isDisposed = true;
        }
    }
}
