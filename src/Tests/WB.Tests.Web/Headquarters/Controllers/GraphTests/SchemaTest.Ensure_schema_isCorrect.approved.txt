schema {
  query: HeadquartersQuery
  mutation: HeadquartersMutations
}

type Assignment {
  archived: Boolean!
  createdAtUtc: DateTime!
  email: String
  id: ID!
  interviewsNeeded: Int
  "Will return `null` when assignment is not received by tablet"
  receivedByTabletAtUtc: DateTime
  responsibleId: Uuid!
  webMode: Boolean!
}

type CalendarEvent {
  "Comment of calendar Event"
  comment: String
  "Id of Calendar Event"
  publicKey: Uuid!
  "Start of calendar Event"
  startUtc: DateTime!
  "Timezone of Start Event"
  startTimezone: String
}

type CategoricalOption {
  parentValue: Int
  title: String!
  value: Int!
}

type Entity {
  identifying: Boolean
  label: String
  options: [CategoricalOption!]!
  "Question text. May contain html tags."
  questionText: String
  scope: QuestionScope
  type: QuestionType!
  variable: String
}

type HeadquartersMutations {
  addUserToMap("Map file name" fileName: String! userName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "Supervisor", "ApiUser" ])
  deleteMap("Map file name" fileName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "ApiUser" ])
  deleteUserFromMap("Map file name" fileName: String! userName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "Supervisor", "ApiUser" ])
}

type HeadquartersQuery {
  assignments(skip: Int take: Int where: AssignmentsFilter): IPagedConnectionOfAssignment @authorize(apply: BEFORE_RESOLVER)
  interviews(order_by: InterviewSort skip: Int take: Int where: InterviewFilter): IPagedConnectionOfInterview @authorize(apply: BEFORE_RESOLVER)
  maps(order_by: MapsSort skip: Int take: Int where: MapsFilter): IPagedConnectionOfMap @authorize(apply: BEFORE_RESOLVER)
  questionnaireItems("Questionnaire id" id: Uuid! "Questionnaire language" language: String "Questionnaire version" version: Long! where: QuestionnaireItemsFilter): [QuestionnaireItem] @authorize(apply: BEFORE_RESOLVER)
  "Gets questionnaire details"
  questionnaires("Questionnaire id" id: Uuid skip: Int take: Int "Questionnaire version" version: Long): IPagedConnectionOfQuestionnaire @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "ApiUser" ])
  questions("Questionnaire id" id: Uuid! "Questionnaire language" language: String "Questionnaire version" version: Long! where: QuestionFilter): [Entity] @authorize(apply: BEFORE_RESOLVER)
  viewer: User @authorize(apply: BEFORE_RESOLVER)
}

type IPagedConnectionOfAssignment {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Assignment]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfInterview {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Interview]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfMap {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Map]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfQuestionnaire {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Questionnaire]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IdentifyingEntity {
  "Answer value for categorical questions"
  answerValue: Int
  entity: Entity!
  value: String
  "Lower cased version of value"
  valueLowerCase: String
}

type Interview {
  "List of actions that can be applied to interview"
  actionFlags: [InterviewActionFlags!]!
  "Identifier for the assignment to which this interview belongs"
  assignmentId: Int
  "Active Calendar Event associated with interview"
  calendarEvent: CalendarEvent
  "Key that was generated on interviewer tablet when interview was created for the first time"
  clientKey: String!
  "Date when interview was created"
  createdDate: DateTime!
  "Shows total number of invalid questions and static texts in the interview. Multiple failed validation conditions on same entity are counted as 1"
  errorsCount: Int!
  id: ID!
  "Information that identifies each assignment. These are the answers to questions marked as identifying in Designer"
  identifyingData: [IdentifyingEntity]
  "Short case identifier that appears throughout the system - in Headquarters, Supervisor, and Interviewer"
  key: String!
  "Number of questions without answer. Includes supervisor, identifying and interviewer questions. Can contain nulls for interviews that were completed prior to 20.09 release"
  notAnsweredCount: Int
  questionnaireId: Uuid!
  questionnaireVariable: String!
  questionnaireVersion: Long!
  "Indicator for whether the interview is on the interviewer’s tablet now"
  receivedByInterviewer: Boolean!
  "Represents date (UTC) when the interview was received by the interviewer’s tablet"
  receivedByInterviewerAtUtc: DateTime
  responsibleId: Uuid!
  "Login of current responsible user"
  responsibleName: String!
  "Lower cased version of responsibleName field"
  responsibleNameLowerCase: String!
  responsibleRole: UserRoles!
  status: InterviewStatus!
  "Supervisor login who is responsible for interview"
  supervisorName: String
  "Lowercased version of supervisor login who is responsible for interview"
  supervisorNameLowerCase: String
  "Represents date (UTC) when interview was changed last time"
  updateDate: DateTime!
  "Indicates if interview was ever completed by interviewer"
  wasCompleted: Boolean!
}

type Map {
  "Map file name"
  fileName: String!
  "Utc date when map was imported on HQ"
  importDate: DateTime
  maxScale: Float!
  minScale: Float!
  "Size of map in bytes"
  size: Long!
  "List of users assigned to map"
  users: [UserMap]
  wkid: Int!
  xMaxVal: Float!
  xMinVal: Float!
  yMaxVal: Float!
  yMinVal: Float!
}

type Questionnaire {
  defaultLanguageName: String
  id: ID
  questionnaireId: Uuid!
  title: String!
  translations: [Translation!]!
  variable: String!
  version: Long!
}

type QuestionnaireItem {
  entityType: EntityType
  identifying: Boolean
  label: String
  options: [CategoricalOption!]!
  scope: QuestionScope
  "Question text or Variable label. May contain html tags."
  title: String
  type: QuestionType
  variable: String
}

type Translation {
  id: Uuid!
  name: String!
}

type User {
  id: ID!
  roles: [UserRoles!]!
  userName: String!
}

type UserMap {
  "Name of the user assigned to map"
  userName: String
}

input AssignmentsFilter {
  AND: [AssignmentsFilter!]
  archived: Boolean
  OR: [AssignmentsFilter!]
  questionnaireId: QuestionnaireIdentity
  receivedByTabletAtUtc: DateTime
  receivedByTabletAtUtc_gt: DateTime
  receivedByTabletAtUtc_lt: DateTime
  receivedByTabletAtUtc_not: DateTime
  responsibleId: Uuid
  responsibleId_in: [Uuid!]
  responsibleId_not: Uuid
  responsibleId_not_in: [Uuid!]
  webMode: Boolean
}

input IdentifyEntityValueFilter {
  AND: [IdentifyEntityValueFilter!]
  answerCode: Decimal
  answerCode_in: [Decimal]
  answerCode_not: Decimal
  answerCode_not_in: [Decimal]
  entity: QuestionFilter
  OR: [IdentifyEntityValueFilter!]
  "Allows case sensitive equals comparison of answer"
  value: String
  "Allows case insensitive equals comparison of answer"
  valueLowerCase: String
  "Allows case insensitive not equals comparison of answer"
  valueLowerCase_not: String
  "Allows case insensitive not starts with comparison of answer"
  valueLowerCase_not_starts_with: String
  "Allows case insensitive starts with comparison of answer"
  valueLowerCase_starts_with: String
  "Allows case sensitive not equals comparison of answer"
  value_not: String
  "Allows case sensitive not starts with comparison of answer"
  value_not_starts_with: String
  "Allows case sensitive starts with comparison of answer"
  value_starts_with: String
}

input InterviewFilter {
  AND: [InterviewFilter!]
  assignmentId: Int
  assignmentId_in: [Int]
  assignmentId_not: Int
  clientKey: String
  clientKey_contains: String
  clientKey_in: [String]
  clientKey_starts_with: String
  createdDate_gt: DateTime
  createdDate_gte: DateTime
  createdDate_lt: DateTime
  createdDate_lte: DateTime
  createdDate_not_gt: DateTime
  createdDate_not_gte: DateTime
  createdDate_not_lt: DateTime
  createdDate_not_lte: DateTime
  errorsCount: Int
  errorsCount_gt: Int
  identifyingData_some: IdentifyEntityValueFilter
  key: String
  key_contains: String
  key_in: [String]
  key_starts_with: String
  notAnsweredCount: Int
  notAnsweredCount_gt: Int
  notAnsweredCount_gte: Int
  notAnsweredCount_in: [Int]
  notAnsweredCount_lt: Int
  notAnsweredCount_lte: Int
  notAnsweredCount_not: Int
  notAnsweredCount_not_gt: Int
  notAnsweredCount_not_gte: Int
  notAnsweredCount_not_in: [Int]
  notAnsweredCount_not_lt: Int
  notAnsweredCount_not_lte: Int
  OR: [InterviewFilter!]
  questionnaireId: Uuid
  questionnaireVariable: String
  questionnaireVersion: Long
  receivedByInterviewerAtUtc: DateTime
  receivedByInterviewerAtUtc_gt: DateTime
  receivedByInterviewerAtUtc_lt: DateTime
  receivedByInterviewerAtUtc_not: DateTime
  responsibleName: String
  responsibleNameLowerCase: String
  responsibleNameLowerCase_in: [String]
  responsibleNameLowerCase_starts_with: String
  responsibleName_in: [String]
  responsibleName_starts_with: String
  responsibleRole: UserRoles
  status: InterviewStatus
  status_in: [InterviewStatus!]
  status_not: InterviewStatus
  supervisorName: String
  supervisorNameLowerCase: String
  supervisorNameLowerCase_in: [String]
  supervisorNameLowerCase_starts_with: String
  supervisorName_in: [String]
  supervisorName_starts_with: String
  updateDate_gt: DateTime
  updateDate_gte: DateTime
  updateDate_lt: DateTime
  updateDate_lte: DateTime
  updateDate_not_gt: DateTime
  updateDate_not_gte: DateTime
  updateDate_not_lt: DateTime
  updateDate_not_lte: DateTime
}

input InterviewSort {
  assignmentId: SortOperationKind
  createdDate: SortOperationKind
  errorsCount: SortOperationKind
  id: SortOperationKind
  key: SortOperationKind
  notAnsweredCount: SortOperationKind
  questionnaireId: SortOperationKind
  questionnaireVersion: SortOperationKind
  receivedByInterviewerAtUtc: SortOperationKind
  responsibleName: SortOperationKind
  responsibleRole: SortOperationKind
  status: SortOperationKind
  updateDate: SortOperationKind
}

input MapsFilter {
  AND: [MapsFilter!]
  fileName: String
  fileName_in: [String]
  fileName_starts_with: String
  importDate_gt: DateTime
  importDate_gte: DateTime
  importDate_lt: DateTime
  importDate_lte: DateTime
  importDate_not_gt: DateTime
  importDate_not_gte: DateTime
  importDate_not_lt: DateTime
  importDate_not_lte: DateTime
  OR: [MapsFilter!]
  size_gt: Long
  size_gte: Long
  size_lt: Long
  size_lte: Long
  size_not_gt: Long
  size_not_gte: Long
  size_not_lt: Long
  size_not_lte: Long
  users_some: UserMapFilter
}

input MapsSort {
  fileName: SortOperationKind
  importDate: SortOperationKind
  size: SortOperationKind
}

input QuestionFilter {
  AND: [QuestionFilter!]
  "Find only identifying questions"
  identifying: Boolean
  OR: [QuestionFilter!]
  questionText: String
  scope: QuestionScope
  variable: String
}

input QuestionnaireIdentity {
  AND: [QuestionnaireIdentity!]
  id: Uuid
  id_not: Uuid
  OR: [QuestionnaireIdentity!]
  version: Long
  version_gt: Long
  version_gte: Long
  version_in: [Long!]
  version_lt: Long
  version_lte: Long
  version_not: Long
  version_not_gt: Long
  version_not_gte: Long
  version_not_in: [Long!]
  version_not_lt: Long
  version_not_lte: Long
}

input QuestionnaireItemsFilter {
  AND: [QuestionnaireItemsFilter!]
  "Find only identifying entities"
  identifying: Boolean
  OR: [QuestionnaireItemsFilter!]
  scope: QuestionScope
  title: String
  variable: String
}

input UserMapFilter {
  AND: [UserMapFilter!]
  OR: [UserMapFilter!]
  "Allows equals comparison of user"
  userName: String
  "Allows not equals comparison of username"
  userName_not: String
  "Allows not starts with comparison of username"
  userName_not_starts_with: String
  "Allows starts with comparison of username"
  userName_starts_with: String
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum EntityType {
  SECTION
  QUESTION
  STATICTEXT
  VARIABLE
  ROSTER
}

enum InterviewActionFlags {
  CANBEREASSIGNED
  CANBEDELETED
  CANBEAPPROVED
  CANBEUNAPPROVEDBYHQ
  CANBEREJECTED
  CANBERESTARTED
  CANBEOPENED
}

enum InterviewStatus {
  RESTORED
  CREATED
  SUPERVISORASSIGNED
  INTERVIEWERASSIGNED
  REJECTEDBYSUPERVISOR
  READYFORINTERVIEW
  SENTTOCAPI
  RESTARTED
  COMPLETED
  APPROVEDBYSUPERVISOR
  REJECTEDBYHEADQUARTERS
  APPROVEDBYHEADQUARTERS
  DELETED
}

enum QuestionScope {
  INTERVIEWER
  SUPERVISOR
  HEADQUARTER
  HIDDEN
}

enum QuestionType {
  SINGLEOPTION
  MULTYOPTION
  NUMERIC
  DATETIME
  GPSCOORDINATES
  TEXT
  TEXTLIST
  QRBARCODE
  MULTIMEDIA
  AREA
  AUDIO
}

enum SortOperationKind {
  ASC
  DESC
}

enum UserRoles {
  ADMINISTRATOR
  SUPERVISOR
  INTERVIEWER
  HEADQUARTER
  OBSERVER
  APIUSER
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The built-in `Decimal` scalar type."
scalar Decimal

"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http:\/\/en.wikipedia.org\/wiki\/IEEE_floating_point)."
scalar Float

"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID."
scalar ID

"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."
scalar Int

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text."
scalar String

scalar Uuid
