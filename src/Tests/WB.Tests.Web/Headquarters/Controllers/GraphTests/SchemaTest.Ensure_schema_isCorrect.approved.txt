schema {
  query: HeadquartersQuery
  mutation: HeadquartersMutations
}

type Assignment {
  archived: Boolean!
  createdAtUtc: DateTime!
  email: String
  id: ID!
  interviewsNeeded: Int
  "Will return `null` when assignment is not received by tablet"
  receivedByTabletAtUtc: DateTime
  responsibleId: Uuid!
  webMode: Boolean!
}

type CategoricalOption {
  parentValue: Int
  title: String!
  value: Int!
}

type HeadquartersMutations {
  addUserToMap("Map file name" fileName: String! userName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "Supervisor", "ApiUser" ])
  deleteMap("Map file name" fileName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "ApiUser" ])
  deleteUserFromMap("Map file name" fileName: String! userName: String!): Map @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "Supervisor", "ApiUser" ])
}

type HeadquartersQuery {
  assignments(skip: Int take: Int where: AssignmentsFilter): IPagedConnectionOfAssignment @authorize(apply: BEFORE_RESOLVER)
  interviews(order_by: InterviewSort skip: Int take: Int where: InterviewFilter): IPagedConnectionOfInterview @authorize(apply: BEFORE_RESOLVER)
  maps(order_by: MapsSort skip: Int take: Int where: MapsFilter): IPagedConnectionOfMap @authorize(apply: BEFORE_RESOLVER)
  "Gets questionnaire details"
  questionnaires("Questionnaire id" id: Uuid skip: Int take: Int "Questionnaire version" version: Long): IPagedConnectionOfQuestionnaire @authorize(apply: BEFORE_RESOLVER, roles: [ "Administrator", "Headquarter", "ApiUser" ])
  questions("Questionnaire id" id: Uuid! "Questionnaire language" language: String "Questionnaire version" version: Long! where: QuestionFilter): [Question] @authorize(apply: BEFORE_RESOLVER)
  viewer: User @authorize(apply: BEFORE_RESOLVER)
}

type IPagedConnectionOfAssignment {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Assignment]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfInterview {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Interview]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfMap {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Map]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type IPagedConnectionOfQuestionnaire {
  "Filtered count of nodes without paging"
  filteredCount: Int!
  "A flattened list of the nodes."
  nodes: [Questionnaire]!
  "Total count of nodes without filtering applied"
  totalCount: Int!
}

type Interview {
  "List of actions that can be applied to interview"
  actionFlags: [InterviewActionFlags!]!
  "Identifier for the assignment to which this interview belongs"
  assignmentId: Int
  "Utc creation date"
  createdDate: DateTime!
  "Shows total number of invalid questions and static texts in the interview. Multiple failed validation conditions on same entity are counted as 1."
  errorsCount: Int!
  id: ID!
  "Information that identifies each assignment. These are the answers to questions marked as identifying in Designer."
  identifyingQuestions: [QuestionAnswer]
  "Short case identifier that appears throughout the system - in Headquarters, Supervisor, and Interviewer."
  key: String!
  questionnaireId: Uuid!
  questionnaireVariable: String!
  questionnaireVersion: Long!
  "Indicator for whether the interview is on the interviewer’s tablet now"
  receivedByInterviewer: Boolean!
  responsibleId: Uuid!
  "Login of current responsible user"
  responsibleName: String!
  "Lower cased version of responsibleName field"
  responsibleNameLowerCase: String!
  responsibleRole: UserRoles!
  status: InterviewStatus!
  "Supervisor login who is responsible for interview"
  supervisorName: String
  "Lowercased version of supervisor login who is responsible for interview"
  supervisorNameLowerCase: String
  "Represents date (UTC) when interview was changed last time"
  updateDate: DateTime!
  "Indicates if interview was ever completed by interviewer"
  wasCompleted: Boolean!
}

type Map {
  "Map file name"
  fileName: String!
  "Utc date when map was imported on HQ"
  importDate: DateTime
  maxScale: Float!
  minScale: Float!
  "Size of map in bytes"
  size: Long!
  "List of users assigned to map"
  users: [UserMap]
  wkid: Int!
  xMaxVal: Float!
  xMinVal: Float!
  yMaxVal: Float!
  yMinVal: Float!
}

type Question {
  identifying: Boolean
  label: String
  options: [CategoricalOption!]!
  "Question text. May contain html tags."
  questionText: String!
  scope: QuestionScope
  type: QuestionType!
  variable: String!
}

type QuestionAnswer {
  answer: String
  "Lower cased version of answer"
  answerLowerCase: String
  "Answer value for categorical questions"
  answerValue: Int
  question: Question!
}

type Questionnaire {
  defaultLanguageName: String
  id: ID
  questionnaireId: Uuid!
  title: String!
  translations: [Translation!]!
  variable: String!
  version: Long!
}

type Translation {
  id: Uuid!
  name: String!
}

type User {
  id: ID!
  roles: [UserRoles!]!
  userName: String!
}

type UserMap {
  "Name of the user assigned to map"
  userName: String
}

input AssignmentsFilter {
  AND: [AssignmentsFilter!]
  archived: Boolean
  OR: [AssignmentsFilter!]
  responsibleId: Uuid
  responsibleId_in: [Uuid!]
  responsibleId_not: Uuid
  responsibleId_not_in: [Uuid!]
  webMode: Boolean
}

input InterviewFilter {
  AND: [InterviewFilter!]
  assignmentId: Int
  assignmentId_in: [Int]
  assignmentId_not: Int
  createdDate_gt: DateTime
  createdDate_gte: DateTime
  createdDate_lt: DateTime
  createdDate_lte: DateTime
  createdDate_not_gt: DateTime
  createdDate_not_gte: DateTime
  createdDate_not_lt: DateTime
  createdDate_not_lte: DateTime
  errorsCount: Int
  errorsCount_gt: Int
  identifyingQuestions_some: QuestionAnswerFilter
  key: String
  key_contains: String
  key_in: [String]
  key_starts_with: String
  OR: [InterviewFilter!]
  questionnaireId: Uuid
  questionnaireVariable: String
  questionnaireVersion: Long
  receivedByInterviewer: Boolean
  responsibleName: String
  responsibleNameLowerCase: String
  responsibleNameLowerCase_in: [String]
  responsibleNameLowerCase_starts_with: String
  responsibleName_in: [String]
  responsibleName_starts_with: String
  responsibleRole: UserRoles
  status: InterviewStatus
  status_in: [InterviewStatus!]
  status_not: InterviewStatus
  supervisorName: String
  supervisorNameLowerCase: String
  supervisorNameLowerCase_in: [String]
  supervisorNameLowerCase_starts_with: String
  supervisorName_in: [String]
  supervisorName_starts_with: String
  updateDate_gt: DateTime
  updateDate_gte: DateTime
  updateDate_lt: DateTime
  updateDate_lte: DateTime
  updateDate_not_gt: DateTime
  updateDate_not_gte: DateTime
  updateDate_not_lt: DateTime
  updateDate_not_lte: DateTime
}

input InterviewSort {
  assignmentId: SortOperationKind
  createdDate: SortOperationKind
  errorsCount: SortOperationKind
  id: SortOperationKind
  key: SortOperationKind
  questionnaireId: SortOperationKind
  questionnaireVersion: SortOperationKind
  receivedByInterviewer: SortOperationKind
  responsibleName: SortOperationKind
  responsibleRole: SortOperationKind
  status: SortOperationKind
  updateDate: SortOperationKind
}

input MapsFilter {
  AND: [MapsFilter!]
  fileName: String
  fileName_in: [String]
  fileName_starts_with: String
  importDate_gt: DateTime
  importDate_gte: DateTime
  importDate_lt: DateTime
  importDate_lte: DateTime
  importDate_not_gt: DateTime
  importDate_not_gte: DateTime
  importDate_not_lt: DateTime
  importDate_not_lte: DateTime
  OR: [MapsFilter!]
  size_gt: Long
  size_gte: Long
  size_lt: Long
  size_lte: Long
  size_not_gt: Long
  size_not_gte: Long
  size_not_lt: Long
  size_not_lte: Long
  users_some: UserMapFilter
}

input MapsSort {
  fileName: SortOperationKind
  importDate: SortOperationKind
  size: SortOperationKind
}

input QuestionAnswerFilter {
  AND: [QuestionAnswerFilter!]
  "Allows case sensitive equals comparison of answer"
  answer: String
  answerCode: Decimal
  answerCode_in: [Decimal]
  answerCode_not: Decimal
  answerCode_not_in: [Decimal]
  "Allows case insensitive equals comparison of answer"
  answerLowerCase: String
  "Allows case insensitive not equals comparison of answer"
  answerLowerCase_not: String
  "Allows case insensitive not starts with comparison of answer"
  answerLowerCase_not_starts_with: String
  "Allows case insensitive starts with comparison of answer"
  answerLowerCase_starts_with: String
  "Allows case sensitive not equals comparison of answer"
  answer_not: String
  "Allows case sensitive not starts with comparison of answer"
  answer_not_starts_with: String
  "Allows case sensitive starts with comparison of answer"
  answer_starts_with: String
  OR: [QuestionAnswerFilter!]
  question: QuestionFilter
}

input QuestionFilter {
  AND: [QuestionFilter!]
  "Find only identifying questions"
  identifying: Boolean
  OR: [QuestionFilter!]
  questionText: String
  scope: QuestionScope
  variable: String
}

input UserMapFilter {
  AND: [UserMapFilter!]
  OR: [UserMapFilter!]
  "Allows equals comparison of user"
  userName: String
  "Allows not equals comparison of username"
  userName_not: String
  "Allows not starts with comparison of username"
  userName_not_starts_with: String
  "Allows starts with comparison of username"
  userName_starts_with: String
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum InterviewActionFlags {
  CANBEREASSIGNED
  CANBEDELETED
  CANBEAPPROVED
  CANBEUNAPPROVEDBYHQ
  CANBEREJECTED
  CANBERESTARTED
  CANBEOPENED
}

enum InterviewStatus {
  RESTORED
  CREATED
  SUPERVISORASSIGNED
  INTERVIEWERASSIGNED
  REJECTEDBYSUPERVISOR
  READYFORINTERVIEW
  SENTTOCAPI
  RESTARTED
  COMPLETED
  APPROVEDBYSUPERVISOR
  REJECTEDBYHEADQUARTERS
  APPROVEDBYHEADQUARTERS
  DELETED
}

enum QuestionScope {
  INTERVIEWER
  SUPERVISOR
  HEADQUARTER
  HIDDEN
}

enum QuestionType {
  SINGLEOPTION
  MULTYOPTION
  NUMERIC
  DATETIME
  GPSCOORDINATES
  TEXT
  TEXTLIST
  QRBARCODE
  MULTIMEDIA
  AREA
  AUDIO
}

enum SortOperationKind {
  ASC
  DESC
}

enum UserRoles {
  ADMINISTRATOR
  SUPERVISOR
  INTERVIEWER
  HEADQUARTER
  OBSERVER
  APIUSER
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The built-in `Decimal` scalar type."
scalar Decimal

"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http:\/\/en.wikipedia.org\/wiki\/IEEE_floating_point)."
scalar Float

"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID."
scalar ID

"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."
scalar Int

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text."
scalar String

scalar Uuid