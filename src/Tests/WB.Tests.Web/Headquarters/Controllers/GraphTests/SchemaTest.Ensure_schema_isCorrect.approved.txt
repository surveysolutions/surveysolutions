schema {
  query: HeadquartersQuery
}

type CategoricalOption {
  parentValue: Int
  title: String
  value: Int!
}

type HeadquartersQuery {
  interviews(order_by: InterviewSort skip: Int take: Int where: InterviewFilter): IPagedConnection @authorize(apply: BEFORE_RESOLVER)
  questions("Questionnaire language" language: String "Questionnaire variable" variable: String "Questionnaire version" version: Long where: QuestionFilter): [Question] @authorize(apply: BEFORE_RESOLVER)
  viewer: User @authorize(apply: BEFORE_RESOLVER)
}

type IPagedConnection {
  "A flattened list of the nodes."
  nodes: [Interview]
  totalCount: Int
}

type Interview {
  "List of actions that can be applied to interview"
  actionFlags: [InterviewActionFlags!]
  "Identifier for the assignment to which this interview belongs"
  assignmentId: Int
  "Utc creation date"
  createdDate: DateTime!
  "Shows total number of invalid questions and static texts in the interview. Multiple failed validation conditions on same entity are counted as 1."
  errorsCount: Int
  id: ID
  "Information that identifies each assignment. These are the answers to questions marked as identifying in Designer."
  identifyingQuestions: [QuestionAnswer]
  "Short case identifier that appears throughout the system - in Headquarters, Supervisor, and Interviewer."
  key: String
  questionnaireId: Uuid!
  questionnaireVariable: String
  questionnaireVersion: Long!
  "Indicator for whether the interview is on the interviewer’s tablet now"
  receivedByInterviewer: Boolean
  responsibleId: Uuid
  "Login of current responsible user"
  responsibleName: String
  "Lower cased version of responsibleName field"
  responsibleNameLowerCase: String
  responsibleRole: UserRoles
  status: InterviewStatus
  "Supervisor login who is responsible for interview"
  supervisorName: String
  "Lowercased version of supervisor login who is responsible for interview"
  supervisorNameLowerCase: String
  "Represents date (UTC) when interview was changed last time"
  updateDate: DateTime!
  "Indicates if interview was ever completed by interviewer"
  wasCompleted: String
}

type Question {
  identifying: Boolean
  label: String
  options: [CategoricalOption]
  "Question text. May contain html tags."
  questionText: String
  scope: QuestionScope
  type: QuestionType
  variable: String
}

type QuestionAnswer {
  answer: String
  "Lower cased version of answer"
  answerLowerCase: String
  "Answer value for categorical questions"
  answerValue: Int
  question: Question!
}

type User {
  id: Uuid!
  roles: [UserRoles!]
  userName: String
}

input InterviewFilter {
  AND: [InterviewFilter!]
  assignmentId: Int
  assignmentId_in: [Int]
  assignmentId_not: Int
  createdDate_gt: DateTime
  createdDate_gte: DateTime
  createdDate_lt: DateTime
  createdDate_lte: DateTime
  createdDate_not_gt: DateTime
  createdDate_not_gte: DateTime
  createdDate_not_lt: DateTime
  createdDate_not_lte: DateTime
  errorsCount: Int
  errorsCount_gt: Int
  identifyingQuestions_some: QuestionAnswerFilter
  key: String
  key_contains: String
  key_in: [String]
  key_starts_with: String
  OR: [InterviewFilter!]
  questionnaireVariable: String
  questionnaireVersion: Long
  receivedByInterviewer: Boolean
  responsibleName: String
  responsibleNameLowerCase: String
  responsibleNameLowerCase_in: [String]
  responsibleNameLowerCase_starts_with: String
  responsibleName_in: [String]
  responsibleName_starts_with: String
  responsibleRole: UserRoles
  status: InterviewStatus
  status_in: [InterviewStatus!]
  status_not: InterviewStatus
  teamLeadName: String
  teamLeadNameLowerCase: String
  teamLeadNameLowerCase_in: [String]
  teamLeadNameLowerCase_starts_with: String
  teamLeadName_in: [String]
  teamLeadName_starts_with: String
  updateDate_gt: DateTime
  updateDate_gte: DateTime
  updateDate_lt: DateTime
  updateDate_lte: DateTime
  updateDate_not_gt: DateTime
  updateDate_not_gte: DateTime
  updateDate_not_lt: DateTime
  updateDate_not_lte: DateTime
}

input InterviewSort {
  assignmentId: SortOperationKind
  createdDate: SortOperationKind
  errorsCount: SortOperationKind
  id: SortOperationKind
  key: SortOperationKind
  questionnaireId: SortOperationKind
  questionnaireVersion: SortOperationKind
  receivedByInterviewer: SortOperationKind
  responsibleName: SortOperationKind
  responsibleRole: SortOperationKind
  status: SortOperationKind
  updateDate: SortOperationKind
}

input QuestionAnswerFilter {
  AND: [QuestionAnswerFilter!]
  "Allows case sensitive equals comparison of answer"
  answer: String
  answerCode: Decimal
  answerCode_in: [Decimal]
  answerCode_not: Decimal
  answerCode_not_in: [Decimal]
  "Allows case insensitive equals comparison of answer"
  answerLowerCase: String
  "Allows case insensitive not equals comparison of answer"
  answerLowerCase_not: String
  "Allows case insensitive not starts with comparison of answer"
  answerLowerCase_not_starts_with: String
  "Allows case insensitive starts with comparison of answer"
  answerLowerCase_starts_with: String
  "Allows case sensitive not equals comparison of answer"
  answer_not: String
  "Allows case sensitive not starts with comparison of answer"
  answer_not_starts_with: String
  "Allows case sensitive starts with comparison of answer"
  answer_starts_with: String
  OR: [QuestionAnswerFilter!]
  question: QuestionFilter
}

input QuestionFilter {
  AND: [QuestionFilter!]
  "Find only identifying questions"
  identifying: Boolean
  OR: [QuestionFilter!]
  questionText: String
  scope: QuestionScope
  variable: String
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum InterviewActionFlags {
  CANBEREASSIGNED
  CANBEDELETED
  CANBEAPPROVED
  CANBEUNAPPROVEDBYHQ
  CANBEREJECTED
  CANBERESTARTED
  CANBEOPENED
}

enum InterviewStatus {
  RESTORED
  CREATED
  SUPERVISORASSIGNED
  INTERVIEWERASSIGNED
  REJECTEDBYSUPERVISOR
  READYFORINTERVIEW
  SENTTOCAPI
  RESTARTED
  COMPLETED
  APPROVEDBYSUPERVISOR
  REJECTEDBYHEADQUARTERS
  APPROVEDBYHEADQUARTERS
  DELETED
}

enum QuestionScope {
  INTERVIEWER
  SUPERVISOR
  HEADQUARTER
  HIDDEN
}

enum QuestionType {
  SINGLEOPTION
  MULTYOPTION
  NUMERIC
  DATETIME
  GPSCOORDINATES
  TEXT
  TEXTLIST
  QRBARCODE
  MULTIMEDIA
  AREA
  AUDIO
}

enum SortOperationKind {
  ASC
  DESC
}

enum UserRoles {
  ADMINISTRATOR
  SUPERVISOR
  INTERVIEWER
  HEADQUARTER
  OBSERVER
  APIUSER
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The built-in `Decimal` scalar type."
scalar Decimal

"The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID."
scalar ID

"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."
scalar Int

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text."
scalar String

scalar Uuid