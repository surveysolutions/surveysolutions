<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
 
    internal partial class <#=Model.GeneratedTypeName#> : AbstractConditionalLevelInstanceV4<<#=this.Model.GeneratedTypeName#>>, IExpressionExecutableV2
    {
        public <#=Model.GeneratedTypeName#>(decimal[] rosterVector, Identity[] rosterKey, Func<Identity[], Guid, IEnumerable<IExpressionExecutableV2>> getInstances, 
                Dictionary<Guid, Guid[]> conditionalDependencies, Dictionary<Guid, Guid[]> structureDependencies, IInterviewProperties interviewProperties)
            : base(rosterVector, rosterKey, getInstances, conditionalDependencies, structureDependencies, interviewProperties)
        {
        
        <#foreach (var @group in Model.Groups) 
        {#>
            EnablementStates.Add(<#=@group.GeneratedStateName#>.ItemId, <#= @group.GeneratedStateName#>);
        <# }#>
                
        <#foreach (var question in Model.Questions)
        {#>
            EnablementStates.Add(<#=question.GeneratedStateName#>.ItemId, <#=question.GeneratedStateName#>);
        <#
            bool hasAnyValidation = !string.IsNullOrWhiteSpace(question.Validations);                       

            if(hasAnyValidation)
            {#>    
            ValidationExpressions.Add(new Identity(IdOf.<#= question.GeneratedIdName#>, rosterVector), new Func<bool>[] {                             
                <#if(!string.IsNullOrWhiteSpace(question.Validations)) {#>  
                    () => this.IsAnswerEmpty(<#=question.VariableName#>) || <#=question.GeneratedValidationsMethodName#>() , 
                <# }#>
            }); 
        <# }#>
            AddUpdaterToMap(IdOf.<#= question.GeneratedIdName#>, (<#=question.GeneratedTypeName#> val) => {<#=question.GeneratedMemberName#>  = val; });
        <# }#>
        <#foreach (var @roster in Model.Rosters) 
        {#>    
            RosterGenerators.Add(IdOf.<#=@roster.GeneratedIdName#>, (decimals, identities) => new <#=@roster.GeneratedTypeName#>(decimals, identities, this, this.GetInstances, this.ConditionalDependencies, this.StructuralDependencies, this.Quest));
        <# }#>

       <#
	foreach (var method in Model.ConditionMethodsSortedByExecutionOrder) 
    {
#>
		_conditionExpressions.Add(Verifier(<#= method.ConditionMethodName#>, <#=method.StateName#>.ItemId, <#= method.StateName#>));                        
<#
	}
#>

        }         

        public override IExpressionExecutableV2 CopyMembers(Func<Identity[], Guid, IEnumerable<IExpressionExecutableV2>> getInstances)
        {
            var level = new <#=Model.GeneratedTypeName#>(this.RosterVector, this.RosterKey, getInstances, ConditionalDependencies, StructuralDependencies, this.Quest)
            {
                ValidAnsweredQuestions = new HashSet<Guid>(this.ValidAnsweredQuestions),
                InvalidAnsweredQuestions = new HashSet<Guid>(this.InvalidAnsweredQuestions),
                <#foreach (var q in Model.Questions) 
                {#>        
                <#=q.GeneratedMemberName#> = this.<#=q.GeneratedMemberName#>,        
                <#}#>
            };
                 
            ConditionalDependencies = new Dictionary<Guid, Guid[]>(this.ConditionalDependencies);
            StructuralDependencies = new Dictionary<Guid, Guid[]>(this.StructuralDependencies);

            foreach (var state in level.EnablementStates)
            {
                var originalState = this.EnablementStates[state.Key];
                state.Value.PreviousState = originalState.PreviousState;
                state.Value.State = originalState.State;
            }
            
            return level;
        }
				
				
        public IExpressionExecutable CopyMembers(Func<Identity[], Guid, IEnumerable<IExpressionExecutable>> getInstances)
        {
            return null;
        }

        <#foreach (var question in Model.Questions) 
        {#>            
        private <#=question.GeneratedTypeName#> <#=question.GeneratedMemberName#> = null;
        private ConditionalState <#= question.GeneratedStateName#> = new ConditionalState(IdOf.<#=question.GeneratedIdName#>);
        public <#=question.GeneratedTypeName#> <#=question.VariableName#>
        {
            get { return <#=question.GeneratedStateName#>.State != State.Disabled ? this.<#=question.GeneratedMemberName#> : null; }
            
        }
        <# }#>
                
        <#foreach (var @roster in Model.Rosters) 
        {#>
        public RosterRowList<<#=@roster.GeneratedTypeName#>> <#=@roster.VariableName#>
        {
            get 
            {
                var rosters = this.GetInstances(new Identity[0], IdOf.<#=@roster.GeneratedRosterScopeName#>.Last());
				return  new RosterRowList<<#=@roster.GeneratedTypeName#>>(rosters);
            }
        }
        <# }#>
        // groups condition states
        <#foreach (var @group in Model.Groups) 
        {#>
        private ConditionalState <#= @group.GeneratedStateName#> = new ConditionalState(IdOf.<#=@group.GeneratedIdName#>, ItemType.Group);
        <# }#>
        
		private readonly IList<Action> _conditionExpressions = new List<Action>();

        protected override IEnumerable<Action> ConditionExpressions
        {
            get
            {
                return _conditionExpressions;
            }
        }

        public void CalculateValidationChanges(out List<Identity> questionsToBeValid, out List<Identity> questionsToBeInvalid)
        {
            this.Validate(out questionsToBeValid, out questionsToBeInvalid);
        }            
        	
        IExpressionExecutableV2 IExpressionExecutableV2.GetParent()
        {
            return null;
        }

		public void SetParent(IExpressionExecutableV2 parentLevel)            
        {            
        }

		public void SetParent(IExpressionExecutable parentLevel)            
        {            
        }

		IExpressionExecutable IExpressionExecutable.GetParent()
        {
            return null;
        }
    }
