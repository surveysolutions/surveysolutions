<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

<#@ import namespace="Main.Core.Entities.SubEntities" #>


using System;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable InconsistentNaming

namespace WB.Core.SharedKernels.ExpressionProcessing
{
    public class InterviewExpressionState : AbstractInterviewExpressionState 
    {

        public InterviewExpressionState() 
        {
            var questionnaireLevelScope = new[] { IdOf.questionnaire };
            var questionnaireIdentityKey = Util.GetRosterKey(questionnaireLevelScope, Util.EmptyRosterVector);
            var questionnaireLevel = new <#=QuestionnaireTemplateStructure.QuestionnaireLevelModel.GetTypeName()#>(Util.EmptyRosterVector, questionnaireIdentityKey, this.GetRosterInstances, IdOf.conditionalDependencies);
            this.InterviewScopes.Add(Util.GetRosterStringKey(questionnaireIdentityKey), questionnaireLevel);
        }

        public InterviewExpressionState(Dictionary<string, IValidatable> interviewScopes, Dictionary<string, List<string>> siblingRosters)
        {
            InterviewScopes = interviewScopes;
            SiblingRosters = siblingRosters;
        }

        public override void AddRoster(Guid rosterId, decimal[] outerRosterVector, decimal rosterInstanceId, int? sortIndex)
        {
            if (!IdOf.rostersIdToScopeMap.ContainsKey(rosterId))
            {
                return;
            }

            decimal[] rosterVector = Util.GetRosterVector(outerRosterVector, rosterInstanceId);
            Guid[] rosterScopeIds = IdOf.rostersIdToScopeMap[rosterId];
            var rosterIdentityKey = Util.GetRosterKey(rosterScopeIds, rosterVector);
            string rosterStringKey = Util.GetRosterStringKey(rosterIdentityKey);

            if (this.InterviewScopes.ContainsKey(rosterStringKey))
            {
                return;
            }

            decimal[] parentRosterVector = outerRosterVector;

            var rosterParentIdentityKey = parentRosterVector.Length == 0
                ? Util.GetRosterKey(new[] { IdOf.questionnaire }, new decimal[0])
                : Util.GetRosterKey(rosterScopeIds.Shrink(), parentRosterVector);

            var parent = this.InterviewScopes[Util.GetRosterStringKey(rosterParentIdentityKey)];

            if (rosterId == IdOf.hhMember || rosterId == IdOf.jobActivity)
            {
                var parentHolder = parent as QuestionnaireLevel;
                var rosterLevel = new HhMember_type(rosterVector, rosterIdentityKey, parentHolder, this.GetRosterInstances, IdOf.conditionalDependencies);
                this.InterviewScopes.Add(rosterStringKey, rosterLevel);
                this.SetSiblings(rosterScopeIds, rosterStringKey);
            }

            if (rosterId == IdOf.foodConsumption)
            {
                var parentHolder = parent as HhMember_type;
                var rosterLevel = new FoodConsumption_type(rosterVector, rosterIdentityKey, parentHolder, this.GetRosterInstances, IdOf.conditionalDependencies);
                this.InterviewScopes.Add(rosterStringKey, rosterLevel);
                this.SetSiblings(rosterScopeIds, rosterStringKey);
            }

            if (rosterId == IdOf.fixedId)
            {
                var parentHolder = parent as QuestionnaireLevel;
                var rosterLevel = new Education_type(rosterVector, rosterIdentityKey, parentHolder, this.GetRosterInstances, IdOf.conditionalDependencies);
                this.InterviewScopes.Add(rosterStringKey, rosterLevel);
                this.SetSiblings(rosterScopeIds, rosterStringKey);
            }
        }

        public override void RemoveRoster(Guid rosterId, decimal[] outerRosterVector, decimal rosterInstanceId)
        {
            if (!IdOf.rostersIdToScopeMap.ContainsKey(rosterId))
            {
                return;
            }

            decimal[] rosterVector = Util.GetRosterVector(outerRosterVector, rosterInstanceId);
            var rosterIdentityKey = Util.GetRosterKey(IdOf.rostersIdToScopeMap[rosterId], rosterVector);
            
            var dependentRosters = this.InterviewScopes.Keys.Where(x => x.StartsWith(Util.GetRosterStringKey((rosterIdentityKey)))).ToArray();
            
            foreach (var rosterKey in dependentRosters)
            {
                this.InterviewScopes.Remove(rosterKey);
                foreach (var siblings in this.SiblingRosters.Values)
                {
                    siblings.Remove(rosterKey);
                }
            }
        }

        public override void UpdateIntAnswer(Guid questionId, decimal[] rosterVector, long answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.persons_count)
            {
                (targetLevel as QuestionnaireLevel).persons_count = answer;
            }

            if (questionId == IdOf.age)
            {
                (targetLevel as HhMember_type).age = answer;
            }

            if (questionId == IdOf.times_per_week)
            {
                (targetLevel as FoodConsumption_type).times_per_week = answer;
            }
        }

        public override void UpdateDecimalAnswer(Guid questionId, decimal[] rosterVector, decimal answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.price_for_food)
            {
                (targetLevel as FoodConsumption_type).price_for_food = answer;
            }
        }

        public override void UpdateDateAnswer(Guid questionId, decimal[] rosterVector, DateTime answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.date)
            {
                (targetLevel as HhMember_type).date = answer;
            }
        }

        public override void UpdateTextAnswer(Guid questionId, decimal[] rosterVector, string answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.id)
            {
                (targetLevel as QuestionnaireLevel).id = answer;
            }

            if (questionId == IdOf.name)
            {
                (targetLevel as HhMember_type).name = answer;
            }

            if (questionId == IdOf.job_title)
            {
                (targetLevel as HhMember_type).job_title = answer;
            }

            if (questionId == IdOf.person_id)
            {
                (targetLevel as HhMember_type).person_id = answer;
            }
        }
        
        public override void UpdateQrBarcodeAnswer(Guid questionId, decimal[] rosterVector, string answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;
        }

        public override void UpdateSingleOptionAnswer(Guid questionId, decimal[] rosterVector, decimal answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.sex)
            {
                (targetLevel as HhMember_type).sex = answer;
            }

            if (questionId == IdOf.role)
            {
                (targetLevel as HhMember_type).role = answer;
            }

            if (questionId == IdOf.has_job)
            {
                (targetLevel as HhMember_type).has_job = answer;
            }

            if (questionId == IdOf.marital_status)
            {
                (targetLevel as HhMember_type).marital_status = answer;
            }

            if (questionId == IdOf.edu_visit)
            {
                (targetLevel as QuestionnaireLevel).edu_visit = answer;
            }

            if (questionId == IdOf.edu)
            {
                (targetLevel as Education_type).edu = answer;
            }
        }

        public override void UpdateMultiOptionAnswer(Guid questionId, decimal[] rosterVector, decimal[] answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.food)
            {
                (targetLevel as HhMember_type).food = answer;
            }
        }

        public override void UpdateGeoLocationAnswer(Guid questionId, decimal[] rosterVector, double latitude, double longitude)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;
        }

        public override void UpdateTextListAnswer(Guid questionId, decimal[] rosterVector, Tuple<decimal, string>[] answers)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;
        }

        public override void UpdateLinkedSingleOptionAnswer(Guid questionId, decimal[] rosterVector, decimal[] selectedPropagationVector)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.best_job_owner)
            {
                (targetLevel as HhMember_type).best_job_owner = selectedPropagationVector;
            }
        }

        public override void UpdateLinkedMultiOptionAnswer(Guid questionId, decimal[] rosterVector, decimal[][] answer)
        {
            var targetLevel = this.GetRosterByIdAndVector(questionId, rosterVector);
            if (targetLevel == null) return;

            if (questionId == IdOf.married_with)
            {
                (targetLevel as HhMember_type).married_with = answer;
            }
        }


        ////


        public override Dictionary<Guid, Guid[]> GetParentsMap()
        {
            return IdOf.parentsMap;
        }

        public override IInterviewExpressionState Clone()
        {
            var newScopes = this.InterviewScopes.ToDictionary(interviewScope => interviewScope.Key, interviewScope => interviewScope.Value.CopyMembers());
            var newSiblingRosters = this.SiblingRosters
                .ToDictionary(
                    interviewScope => interviewScope.Key,
                    interviewScope => new List<string>(interviewScope.Value));

            //set parents
            foreach (var interviewScope in this.InterviewScopes)
            {
                var parent = interviewScope.Value.GetParent();
                if (parent != null)
                    newScopes[interviewScope.Key].SetParent(newScopes[Util.GetRosterStringKey(parent.GetRosterKey())]);
            }

            return new InterviewExpressionState(newScopes, newSiblingRosters);
        }

        //generate QuestionnaireLevel
        <#           
                QuestionnaireLevelTemplate questionnairetemplate = new QuestionnaireLevelTemplate(QuestionnaireTemplateStructure.QuestionnaireLevelModel);
                this.Write(questionnairetemplate .TransformText());                           
         #>

        //generating all rosters
         <#foreach (var roster in QuestionnaireTemplateStructure.Rosters) 
           {
                RosterTemplate template = new RosterTemplate(roster);
                this.Write(template.TransformText());                
           }
         #>


        public static class IdOf
        {
            public static readonly Guid questionnaire = <#= QuestionnaireTemplateStructure.Id #>; //Guid.Parse("72897e3f-3dc8-4115-81e0-8a9c1cadec2d");

            //questions
            <#foreach (var q in QuestionnaireTemplateStructure.Questions) 
            {#>
              public static readonly Guid <#= q.VariableName#> = <#= q.Id #>;
            <# }#>           
            
            //rosters
            <#foreach (var r in QuestionnaireTemplateStructure.Rosters) 
            {#>
              public static readonly Guid <#= r.VariableName#> = <#= r.Id #>;
            <# }#>

            //public static readonly Guid hhMember = Guid.Parse("69b02bcf-0ed1-4b5a-80bb-bd465ab096da");
            
            //generate groups Ids
            <#foreach (var g in QuestionnaireTemplateStructure.Groups) 
            {#>
              public static readonly Guid <#= g.VariableName#> = <#= g.Id #>;
            <# }#>
            //public static readonly Guid groupId = Guid.Parse("039ed69e-5583-46af-b983-488568f20e1c");
            
            //TODO: generate scopes
            public static readonly Guid[] eduScopeIds = new[] { fixedId };
            public static readonly Guid[] hhMemberScopeIds = new[] { persons_count };
            public static readonly Guid[] foodConsumptionIds = new[] { persons_count, food };

            
            public static Dictionary<Guid, Guid[]> conditionalDependencies = new Dictionary<Guid, Guid[]>()
            {
            <#foreach (var dependency in QuestionnaireTemplateStructure.ConditionalDependencies) 
            {#>
              { <#= dependency.Key #>, new Guid[]{
              <#foreach (var d in dependency.Value)
                    {#>
                    <#= d #>,
                    <# }#>
              }}
            <# }#>

                //{ id, new Guid[] { } },
                //{ persons_count, new Guid[] { married_with } },
                //{ edu_visit, new Guid[] { fixedId } },

            };

            public static Dictionary<Guid, Guid[]> parentsMap = new Dictionary<Guid, Guid[]>
            {
            { id, new []{questionnaire} },
            { persons_count, new []{questionnaire}},
            { edu_visit, new []{questionnaire} },
            { name, hhMemberScopeIds },
            { age, hhMemberScopeIds },
            { date, hhMemberScopeIds },
            { sex, hhMemberScopeIds },
            { role, hhMemberScopeIds },
            { food, hhMemberScopeIds },
            { times_per_week, foodConsumptionIds },
            { price_for_food, foodConsumptionIds },
            { has_job, hhMemberScopeIds },
            { job_title, hhMemberScopeIds },
            { best_job_owner, hhMemberScopeIds },
            { person_id, hhMemberScopeIds },
            { marital_status, hhMemberScopeIds },
            { married_with, hhMemberScopeIds },
            { edu, eduScopeIds },

            //groups
            { groupId, hhMemberScopeIds },
            { fixedId, eduScopeIds },
            { hhMember, hhMemberScopeIds },
            { foodConsumption, foodConsumptionIds },
            
        };

            public static Dictionary<Guid, Guid[]> rostersIdToScopeMap = new Dictionary<Guid, Guid[]>
        {
            { fixedId, eduScopeIds },
            { hhMember, hhMemberScopeIds },
            { foodConsumption, foodConsumptionIds },
            { jobActivity, hhMemberScopeIds }
        };
        }
    }
}

// ReSharper restore InconsistentNaming