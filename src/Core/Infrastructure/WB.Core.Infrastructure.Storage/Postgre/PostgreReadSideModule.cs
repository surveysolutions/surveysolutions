using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using NHibernate;
using NHibernate.Cfg;
using NHibernate.Cfg.MappingSchema;
using NHibernate.Mapping;
using NHibernate.Mapping.ByCode;
using NHibernate.Mapping.ByCode.Conformist;
using NHibernate.Tool.hbm2ddl;
using Ninject;
using Ninject.Activation;
using Ninject.Web.Common;
using WB.Core.Infrastructure.ReadSide.Repository.Accessors;
using WB.Core.Infrastructure.Storage.Memory.Implementation;
using WB.Core.Infrastructure.Storage.Postgre.Implementation;
using WB.Core.Infrastructure.Transactions;
using WB.Core.SharedKernels.SurveySolutions;

namespace WB.Core.Infrastructure.Storage.Postgre
{
    public class PostgreModule : Ninject.Modules.NinjectModule
    {
        private readonly string connectionString;
        private readonly IEnumerable<Assembly> mappingAssemblies;

        public PostgreModule(string connectionString,
            IEnumerable<Assembly> mappingAssemblies)
        {
            this.connectionString = connectionString;
            this.mappingAssemblies = mappingAssemblies;
        }

        public override void Load()
        {
            this.Kernel.Bind<PostgreConnectionSettings>().ToConstant(new PostgreConnectionSettings{ConnectionString = connectionString });

            this.Kernel.Bind<IReadSideCleaner>().To<PostgresReadSideCleaner>();

            this.Kernel.Bind(typeof(PostgreReadSideRepository<>)).ToSelf().InSingletonScope();
            this.Kernel.Bind(typeof(MemoryCachedReadSideRepositoryWriterProvider<>)).ToSelf();
            this.Kernel.Bind(typeof(IReadSideRepositoryWriter<>)).ToMethod(GetReadSideRepositoryWriter).InSingletonScope(); 
            
            this.Kernel.Bind<ISessionFactory>()
                       .ToMethod(kernel => this.BuildSessionFactory())
                       .InSingletonScope();

            this.Kernel.Bind<PostgreTransactionManager>().To<PostgreTransactionManager>().InRequestScope();
            this.Kernel.Bind<Func<PostgreTransactionManager>>().ToMethod(kernel => () => kernel.Kernel.Get<PostgreTransactionManager>());

            this.Kernel.Bind<TransactionManagerProvider>().ToSelf().InSingletonScope();

            this.Kernel.Bind<ISessionProvider>().ToMethod(context => context.Kernel.Get<TransactionManagerProvider>());
            this.Kernel.Bind<ITransactionManager>().To<PostgreTransactionManager>();

            this.Kernel.Bind<ITransactionManagerProvider>().ToMethod(context => context.Kernel.Get<TransactionManagerProvider>());
            this.Kernel.Bind<ITransactionManagerProviderManager>().ToMethod(context => context.Kernel.Get<TransactionManagerProvider>());

            this.Kernel.Bind(typeof (IQueryableReadSideRepositoryReader<>)).To(typeof (PostgreReadSideRepository<>));
            this.Kernel.Bind(typeof (IReadSideRepositoryReader<>)).To(typeof (PostgreReadSideRepository<>));

            //this.Kernel.Bind(typeof(IReadSideKeyValueStorage<>))
            //    .ToMethod(GetReadSideKeyValueStorage)
            //    .InSingletonScope();
        }

        private ISessionFactory BuildSessionFactory()
        {
            //File.WriteAllText(@"D:\Temp\Mapping.xml" ,Serialize(this.GetMappings()));
            var cfg = new Configuration();
            cfg.DataBaseIntegration(db =>
            {
                db.ConnectionString = connectionString;
                db.Dialect<NHibernate.Dialect.PostgreSQL82Dialect>();
                db.KeywordsAutoImport = Hbm2DDLKeyWords.AutoQuote;
            });

            cfg.AddDeserializedMapping(GetMappings(), "Main");
            var update = new SchemaUpdate(cfg);
            update.Execute(true, true);


            return cfg.BuildSessionFactory();
        }

        /// <summary>
        /// Generates XML string from <see cref="NHibernate"/> mappings. Used just to verify what was generated by ConfOrm to make sure everything is correct.
        /// </summary>
        protected static string Serialize(HbmMapping hbmElement)
        {
            var setting = new XmlWriterSettings { Indent = true };
            var serializer = new XmlSerializer(typeof(HbmMapping));
            using (var memStream = new MemoryStream())
            {
                using (var xmlWriter = XmlWriter.Create(memStream, setting))
                {
                    serializer.Serialize(xmlWriter, hbmElement);
                    memStream.Flush();
                    byte[] streamContents = memStream.ToArray();

                    string result = Encoding.UTF8.GetString(streamContents);
                    return result;
                }
            }
        }

        private HbmMapping GetMappings()
        {
            var mapper = new ModelMapper();
            var mappingTypes = this.mappingAssemblies.SelectMany(x => x.GetExportedTypes())
                                                     .Where(x => IsSubclassOfRawGeneric(typeof(ClassMapping<>), x));
            mapper.AddMappings(mappingTypes);
            mapper.BeforeMapProperty += (inspector, member, customizer) =>
            {
                var propertyInfo = (PropertyInfo) member.LocalMember;
                if (propertyInfo.PropertyType == typeof (string))
                {
                    customizer.Type(NHibernateUtil.StringClob);
                }
            };

            return mapper.CompileMappingForAllExplicitlyAddedEntities();
        }

        static bool IsSubclassOfRawGeneric(Type generic, Type toCheck)
        {
            while (toCheck != null && toCheck != typeof(object))
            {
                var cur = toCheck.IsGenericType ? toCheck.GetGenericTypeDefinition() : toCheck;
                if (generic == cur)
                {
                    return true;
                }
                toCheck = toCheck.BaseType;
            }
            return false;
        }

        private object GetReadSideKeyValueStorage(IContext context)
        {
            var genericProvider = this.Kernel.Get(
                typeof(MemoryCachedKeyValueStorageProvider<>).MakeGenericType(context.GenericArguments[0])) as
                IProvider;

            if (genericProvider == null)
                return null;
            return genericProvider.Create(context);
        }

        private class MemoryCachedKeyValueStorageProvider<TEntity> : Provider<IReadSideKeyValueStorage<TEntity>>
            where TEntity : class, IReadSideRepositoryEntity
        {
            protected override IReadSideKeyValueStorage<TEntity> CreateInstance(IContext context)
            {
                return new MemoryCachedKeyValueStorage<TEntity>(context.Kernel.Get<PostgreKeyValueStorage<TEntity>>());
            }
        }

        private class MemoryCachedReadSideRepositoryWriterProvider<TEntity> : Provider<IReadSideRepositoryWriter<TEntity>>
       where TEntity : class, IReadSideRepositoryEntity
        {
            protected override IReadSideRepositoryWriter<TEntity> CreateInstance(IContext context)
            {
                return new MemoryCachedReadSideRepositoryWriter<TEntity>(context.Kernel.Get<PostgreReadSideRepository<TEntity>>());
            }
        }

        protected object GetReadSideRepositoryWriter(IContext context)
        {
            var genericProvider = this.Kernel.Get(
                  typeof(MemoryCachedReadSideRepositoryWriterProvider<>).MakeGenericType(context.GenericArguments[0])) as
                  IProvider;

            if (genericProvider == null)
                return null;
            return genericProvider.Create(context);
        }
    }
}